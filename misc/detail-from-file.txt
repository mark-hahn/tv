
# Exact torrent detailUrl linking (final decisions + complete logic)

Goal: alt-click a local media file in the UI and open the *exact* provider detail page(s) for the torrent(s) that produced the file(s).

Decisions (no options):

- Storage: **single JSON file**, kept in memory and flushed with **minimum writes** (debounced + atomic replace).
- Maps:
	- `detailUrlFromHash`: infohash → provider detail URL (captured at download time).
	- `hashFromFilePath`: local file path → infohash (captured by tv-proc at copy time).
- Matching in tv-proc: use **exact containment**: `usbAbsolutePath == qbtRootAbsolutePath + relativeTorrentFilePath`.
- Identity: **do not** implement stronger identity than file path.
- Endpoint responses: **no debug fields**.
- New requirement: when tv-proc receives one `localPath`, it expands to *all* video files in the same season folder that match `parse-torrent-title` of that one file, and returns multiple results; the client opens *all* returned detail pages.


## Storage (one JSON file, minimum flushes)

File: `torrents/data/torrent-links.json`

In-memory state:

- Load once at process start (or first use).
- Mutate in memory.
- Flush on a debounce timer (e.g. 5 seconds) and also on clean shutdown.
- Flush implementation: write to `…json.tmp` then rename to `…json` (atomic replace).

Access pattern (no extra RPC needed):

- The torrents server download pipeline is the writer.
- The tv-proc endpoints are readers (and also writers for `hashFromFilePath`).
- Since tv-proc runs inside the torrents server (or at least on the same host with filesystem access), it can load the same JSON file via a shared module (single in-memory state).

Top-level structure:

```json
{
	"version": 1,
	"updatedAt": "2026-01-09T12:34:56.000Z",
	"detailUrlFromHash": {
		"<40-hex>": { "...record" : true }
	},
	"hashFromFilePath": {
		"D:/media/Shows/Foo/Season 01/Foo - S01E02.mkv": { "...record" : true }
	}
}
```


## Map 1: `detailUrlFromHash` (infohash → provider detail URL)

Key: `infoHash` (lowercase hex string; qBittorrent “hash”)

Record (include all properties):

```json
{
	"infoHash": "<40-hex>",
	"detailUrl": "https://…",
	"provider": "torrentleech|iptorrents|…",
	"title": "<display title from search>",
	"torrentName": "<qbt name at time of mapping>",
	"totalSize": 1234567890,
	"tracker": "<optional tracker host>",
	"addedAt": "2026-01-09T12:34:56.000Z",
	"createdAt": "2026-01-09T12:34:56.000Z"
}
```

How it’s created (download time):

1) Tor pane selects a provider search result → torrents server already has `detailUrl`.
2) Torrents server also has `.torrent` bytes or magnet for that exact result.
3) Torrents server computes infohash deterministically.
4) Torrents server writes `detailUrlFromHash[infoHash] = record` into the shared JSON state.

Important: tv-proc never receives “provider search results”. It only reads the persisted `detailUrlFromHash` map later.


## Map 2: `hashFromFilePath` (local file path → infohash)

Key: normalized `localPath` string.

Record (include all properties):

```json
{
	"localPath": "D:/media/Shows/Foo/Season 01/Foo - S01E02.mkv",
	"infoHash": "<40-hex>",
	"usbPath": "X:/torrents/Foo.S01E02.1080p/Foo.S01E02.1080p.mkv",
	"bytes": 1234567890,
	"mtimeMs": 1736420000000,
	"basename": "Foo - S01E02.mkv",
	"qbtSavePath": "X:/torrents",
	"qbtContentPath": "X:/torrents/Foo.S01E02.1080p",
	"confidence": 1.0,
	"copiedAt": "2026-01-09T12:34:56.000Z"
}
```

How it’s created (copy time, tv-proc):

Inputs already known by tv-proc when it copies:

- `usbPath` (source)
- `localPath` (destination)

Algorithm to find `infoHash`:

1) Get candidate torrents from qBittorrent: `GET /api/v2/torrents/info`.
2) For each candidate torrent:
	- Pull its file list: `GET /api/v2/torrents/files?hash=<hash>`.
	- Compute the torrent root absolute path:
		- Use `content_path` if available, otherwise `save_path + name`.
	- For each file entry, compute `candidateUsbAbs = torrentRootAbs + '/' + fileEntry.name` (with path normalization).
	- If `candidateUsbAbs` equals the known `usbPath` (exact string match after normalization), select this torrent hash.
3) When found:
	- Fill `hashFromFilePath[localPath] = record` with the fields above.
	- Set `confidence = 1.0` for an exact containment match.


## tv-proc endpoint used by map.vue (batch results)

Purpose: given a single clicked `localPath`, return **multiple** `{ infoHash, detailUrl }` results for other video files in the same season folder that match `parse-torrent-title` of the clicked file.

Endpoint:

`POST /api/tvproc/resolveDetailUrls`

Request:

```json
{
	"localPath": "D:/media/Shows/Foo/Season 01/Foo - S01E02.mkv"
}
```

Response (success):

```json
{
	"ok": true,
	"results": [
		{
			"localPath": "D:/media/Shows/Foo/Season 01/Foo - S01E01.mkv",
			"infoHash": "<40-hex>",
			"detailUrl": "https://…",
			"provider": "torrentleech|iptorrents|…",
			"title": "<display title>"
		}
	]
}
```

Response (none found):

```json
{
	"ok": false,
	"error": "no detail urls"
}
```

Server-side logic for `POST /api/tvproc/resolveDetailUrls`:

1) Parse the input filename with `parse-torrent-title`.
	- Extract at least: `title` (normalized) and `season`.
2) Determine `seasonFolder = dirname(localPath)`.
3) List files in `seasonFolder` and filter to “video-ish” extensions:
	- `.mkv`, `.mp4`, `.m4v`, `.avi`, `.mov`
4) For each video file `candidateLocalPath` in that folder:
	- Parse with `parse-torrent-title`.
	- Keep it if parsed `title` matches the clicked file’s parsed `title` and parsed `season` matches.
5) For each kept `candidateLocalPath`:
	- Look up `infoHash` via `hashFromFilePath[candidateLocalPath]`.
	- Look up `detail` via `detailUrlFromHash[infoHash]`.
	- If both exist, append one entry to `results`:
		- `{ localPath, infoHash, detailUrl, provider, title }`
6) If `results.length > 0`, return `{ ok:true, results }`, else `{ ok:false, error:"no detail urls" }`.


## Client behavior (map.vue / alt-click)

On alt-click of a map cell:

1) Determine the clicked episode’s `localPath`.
2) Call `POST /api/tvproc/resolveDetailUrls`.
3) If `ok:true`, for each item in `results`, `window.open(detailUrl, '_blank')`.
4) If `ok:false`, do nothing (or show a simple toast; no endpoint debug details required).


## Pruning

- `detailUrlFromHash`: keep indefinitely.
- `hashFromFilePath`: prune entries whose `localPath` no longer exists OR older than N months.

