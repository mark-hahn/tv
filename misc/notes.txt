
Where the worker “updates a show”

Worker computes fileGap/etc, then sends a message: gap-worker.js:170-205 (self.postMessage({ showId, ... })).
The UI-side mutation happens in addGapToShow(event): list.vue:1492-1542
Finds the show: const show = allShows.find((show) => show.Id == showId);
Applies fields onto it: Object.assign(show, gap);
Persists to server: await srvr.addGap([show.Id, gap, save]);
Where addGap is called

Only here: list.vue:1533 (srvr.addGap(...))
Where delGap is called

When deleting a show from the server side of the client workflow: srvr.js:104-116 (deleteShowFromSrvr calls delGap([show.Id, true]))
During Emby load, cleaning gaps with no matching show: emby.js:256-260
Where the worker is started / callback wired

Worker creation: emby.js:7-10
Wiring onmessage + postMessage: emby.js:327-342
Start call (and restart logic): list.vue:1549-1580
If you’re asking because the UI isn’t repainting when gaps change: the mutation currently targets the allShows object found outside Vue’s reactive state, which can bypass reactivity depending on how those objects are proxied. If you want, I can adjust addGapToShow to assign onto the reactive object in this.shows (or make allShows reactive) so the list always updates immediately.