#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SSH_HOST="hahnca.com"
REMOTE_WORKTREE_BASE="/mnt/media/archive/dev/apps/tv-worktrees"

# This script deploys the *current working tree* via rsync (no git).
#
# By default it deploys to: $REMOTE_WORKTREE_BASE/main
# Override with:
#   TV_DEPLOY_NAME=feature-x ./srvr [srvr|down|api]

DEPLOY_NAME="${TV_DEPLOY_NAME:-main}"
DEPLOY_NAME="${DEPLOY_NAME//\//__}"
REMOTE_DIR="$REMOTE_WORKTREE_BASE/$DEPLOY_NAME"

if [[ ! -d "$ROOT_DIR/apps" ]]; then
  echo "Error: expected monorepo layout under $ROOT_DIR (missing apps/)" >&2
  exit 1
fi

usage() {
  echo "Usage: $(basename "$0") [srvr|down|api]" >&2
  echo "Env: TV_DEPLOY_NAME (default: main)" >&2
  exit 1
}

pm2_name_for_project() {
  case "$1" in
    api)  printf '%s' "tv-api" ;;
    down) printf '%s' "tv-down" ;;
    srvr) printf '%s' "tv-srvr" ;;
    *) return 1 ;;
  esac
}

remote_sync_tree() {
  echo "[remote] syncing working tree via rsync -> $SSH_HOST:$REMOTE_DIR"
  ssh "$SSH_HOST" "mkdir -p '$REMOTE_DIR'"

  # Prefer rsync (fast). If remote doesn't have rsync, fall back to tar-over-ssh.
  if ssh "$SSH_HOST" 'command -v rsync >/dev/null 2>&1'; then
    rsync -az --delete \
      --exclude '.git/' \
      --exclude '.tv-deps.sha' \
      --exclude 'node_modules/' \
      --exclude '.turbo/' \
      --exclude 'dist/' \
      --exclude 'build/' \
      --exclude '.output/' \
      --exclude '.imports/' \
      --exclude 'apps/**/node_modules/' \
      --exclude 'apps/**/dist/' \
      --exclude 'apps/**/build/' \
      --exclude 'apps/**/.turbo/' \
      --exclude 'apps/**/.output/' \
      --exclude 'apps/**/.cache/' \
      --exclude 'apps/**/.vite/' \
      --exclude 'apps/**/.nuxt/' \
      --exclude 'apps/**/.next/' \
      --exclude 'apps/**/.svelte-kit/' \
      --exclude 'apps/**/.parcel-cache/' \
      "$ROOT_DIR/" "$SSH_HOST:$REMOTE_DIR/"
  else
    echo "[warn] rsync not found on remote; using tar-over-ssh" >&2
    tar \
      --exclude='.git' \
      --exclude='node_modules' \
      --exclude='.turbo' \
      --exclude='dist' \
      --exclude='build' \
      --exclude='.output' \
      --exclude='.imports' \
      -C "$ROOT_DIR" -cf - . \
      | ssh "$SSH_HOST" "tar -C '$REMOTE_DIR' -xpf -"
  fi
}

remote_install_deps() {
  # Ensure runtime deps exist before starting PM2.
  # Avoid pnpm install unless lockfiles changed.
  echo "[remote] deps check: $REMOTE_DIR"
  ssh "$SSH_HOST" "cd '$REMOTE_DIR' && command -v corepack >/dev/null 2>&1 && corepack enable >/dev/null 2>&1 || true"
  ssh "$SSH_HOST" "cd '$REMOTE_DIR' && if ! command -v pnpm >/dev/null 2>&1; then (command -v corepack >/dev/null 2>&1 && corepack prepare pnpm@latest --activate >/dev/null 2>&1) || true; fi"
  ssh "$SSH_HOST" "cd '$REMOTE_DIR' && command -v pnpm >/dev/null 2>&1 || { echo 'pnpm not found on remote PATH' >&2; exit 1; }"

  ssh "$SSH_HOST" "cd '$REMOTE_DIR' && \
    if [ ! -f pnpm-lock.yaml ]; then \
      echo '[remote] no pnpm-lock.yaml; running pnpm install'; \
      pnpm install; \
    else \
      if command -v sha256sum >/dev/null 2>&1; then H=sha256sum; else H='shasum -a 256'; fi; \
      NEW=\$( ( (\$H pnpm-lock.yaml pnpm-workspace.yaml 2>/dev/null || \$H pnpm-lock.yaml) | \$H ) | awk '{print \$1}' ); \
      OLD=\$(cat .tv-deps.sha 2>/dev/null || true); \
      if [[ -n \"\$NEW\" && \"\$NEW\" == \"\$OLD\" && -d node_modules ]]; then \
        echo '[remote] lockfiles unchanged; skipping pnpm install'; \
      else \
        echo '[remote] lockfiles changed (or missing node_modules); running pnpm install'; \
        pnpm install; \
        printf '%s\n' "\$NEW" > .tv-deps.sha; \
      fi; \
    fi"
}

remote_prepare_runtime_state() {
  # A fresh git worktree will not include runtime state files.
  # tv-srvr requires this file at startup.
  local project="${1:-all}"
  if [[ "$project" == "all" || "$project" == "srvr" ]]; then
    echo "[remote] ensure tv-srvr data/lastViewed.json exists"
    ssh "$SSH_HOST" "cd '$REMOTE_DIR' && mkdir -p 'apps/srvr/data' && [ -f 'apps/srvr/data/lastViewed.json' ] || printf '{}' > 'apps/srvr/data/lastViewed.json'"
  fi
}

remote_pm2_start_all() {
  echo "[pm2] start all from $REMOTE_DIR"
  # Ensure PM2 doesn't retain stale exec paths/cwds across redeploys.
  ssh "$SSH_HOST" "pm2 delete tv-api tv-down tv-srvr >/dev/null 2>&1 || true"
  ssh "$SSH_HOST" "cd '$REMOTE_DIR' && pm2 start ecosystem.config.cjs --env production --update-env && pm2 save"
}

remote_pm2_start_one() {
  local project="$1"
  local pm2_name
  pm2_name="$(pm2_name_for_project "$project")"

  echo "[pm2] start $pm2_name from $REMOTE_DIR"
  ssh "$SSH_HOST" "pm2 delete '$pm2_name' >/dev/null 2>&1 || true"
  ssh "$SSH_HOST" "cd '$REMOTE_DIR' && pm2 start ecosystem.config.cjs --env production --update-env --only '$pm2_name' && pm2 save"
}

remote_pm2_restart_one() {
  local project="$1"
  local pm2_name
  pm2_name="$(pm2_name_for_project "$project")"
  echo "[pm2] restart $pm2_name (fallback to start)"
  ssh "$SSH_HOST" "pm2 restart '$pm2_name' --update-env >/dev/null 2>&1 || (cd '$REMOTE_DIR' && pm2 start ecosystem.config.cjs --env production --update-env --only '$pm2_name')"
  ssh "$SSH_HOST" "pm2 save >/dev/null 2>&1 || true"
}

remote_pm2_restart_all() {
  echo "[pm2] restart all (fallback to start)"
  ssh "$SSH_HOST" "pm2 restart tv-api tv-down tv-srvr --update-env >/dev/null 2>&1 || (cd '$REMOTE_DIR' && pm2 start ecosystem.config.cjs --env production --update-env)"
  ssh "$SSH_HOST" "pm2 save >/dev/null 2>&1 || true"
}

if [[ "${1:-}" == "" ]]; then
  remote_sync_tree
  remote_install_deps
  remote_prepare_runtime_state all
  remote_pm2_restart_all
elif [[ "${1:-}" == "srvr" || "${1:-}" == "down" || "${1:-}" == "api" ]]; then
  remote_sync_tree
  remote_install_deps
  remote_prepare_runtime_state "$1"
  remote_pm2_restart_one "$1"
else
  usage
fi
